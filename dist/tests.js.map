{"version":3,"sources":["../tests/index.ts","../tests/wordCacheTest.ts","../src/sqlite.ts","../src/wordCache.ts"],"sourcesContent":["import { test } from 'uvu';\r\nimport './wordCacheTest';\r\n\r\ntest.run();\r\n","import { test } from 'uvu';\r\nimport WordCache from '../src/wordCache';\r\n\r\ntest('WordCache: Basic', async () => {\r\n  console.log();\r\n  const cache = new WordCache(`${process.cwd()}/tests/test.db`).reset();\r\n\r\n  await cache.connect();\r\n\r\n  const usages = await cache.fetch(\r\n    `Bro, we can't even do this like that lol, do don't and get wrecked :D https://www.test.com`\r\n  );\r\n  const user_id = await cache.addUsages(usages, 'test', new Date());\r\n\r\n  const future = new Date(Date.now() + 1000 * 60 * 60 * 5);\r\n  const nextUsage = await cache.fetch(`Bro, we did do it holy cow`);\r\n  await cache.addUsages(nextUsage, user_id, future);\r\n\r\n  const report = await cache.getReport(user_id);\r\n  console.log(report);\r\n});\r\n","import SqliteDatabaseConnection from 'sqlite3';\r\nimport { ensureFileSync } from 'fs-extra';\r\n\r\n/**\r\n * A cache of all connections\r\n */\r\nconst cache: {\r\n  [key: string]: SqliteDatabaseConnection;\r\n} = {};\r\n\r\n/**\r\n * Get a sqlite database connection\r\n */\r\nexport const getDb = (path: string) => {\r\n  if (cache[path] === undefined) {\r\n    ensureFileSync(path);\r\n    cache[path] = new SqliteDatabaseConnection.Database(path);\r\n    cache[path].exec('PRAGMA journal_mode = OFF;');\r\n    cache[path].exec('PRAGMA synchronous = 0;');\r\n    cache[path].exec('PRAGMA cache_size = 1000000;');\r\n    cache[path].exec('PRAGMA locking_mode = EXCLUSIVE');\r\n    cache[path].exec('PRAGMA temp_store = MEMORY;');\r\n  }\r\n\r\n  return cache[path];\r\n};\r\n\r\n/**\r\n *\r\n * @param path\r\n */\r\nexport const reset = (path: string) => {\r\n  cache[path] = undefined;\r\n};\r\n\r\n/**\r\n * run\r\n */\r\nexport const run = <T = Object>(\r\n  db: SqliteDatabaseConnection,\r\n  query: string,\r\n  parameters: Object | undefined = undefined\r\n): Promise<T[]> => {\r\n  return new Promise((resolve) => {\r\n    const statement = db.prepare(query);\r\n    if (parameters === undefined) {\r\n      return statement.run();\r\n    } else {\r\n      return statement.bind(parameters).run(resolve);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * query\r\n * @param query sql\r\n * @param parameters Object\r\n * @param db SqliteDatabaseConnection\r\n * @return Object[]\r\n */\r\nexport const query = <T = Object>(\r\n  db: SqliteDatabaseConnection,\r\n  query: string,\r\n  parameters: Object = {}\r\n): Promise<T[]> => {\r\n  return new Promise((resolve) => {\r\n    const statement = db.prepare(query);\r\n\r\n    statement.bind(parameters).all((err, rows) => {\r\n      console.log('what');\r\n      console.log(err);\r\n      console.log(rows);\r\n      resolve(rows);\r\n    });\r\n  });\r\n};\r\n","import { getDb, run, query, reset } from './sqlite';\r\nimport winkNLP from 'wink-nlp';\r\nimport model from 'wink-eng-lite-web-model';\r\nimport { rmSync } from 'fs-extra';\r\n\r\nconst singleQuotes = /'/g;\r\nconst newLines = /[\\n\\r]/g;\r\nconst msInHour = 1000 * 60 * 60;\r\n\r\n// Instantiate winkNLP.\r\nconst nlp = winkNLP(model);\r\n\r\ninterface Word {\r\n  id: number;\r\n  word: string;\r\n}\r\n\r\ninterface insertResult {\r\n  lastInsertRowid: number;\r\n}\r\n\r\ninterface WordCacheEntries {\r\n  [key: string]: WordCacheEntry;\r\n}\r\n\r\ninterface WordCacheEntry {\r\n  id: number;\r\n  amount: number;\r\n}\r\n\r\ninterface UsageEntry {\r\n  hour: number;\r\n  word_id: number;\r\n  timestamp: number;\r\n}\r\n\r\ninterface User {\r\n  id: number;\r\n  username: string;\r\n}\r\n\r\ninterface UniqueWords {\r\n  hour: number;\r\n  uniqueCount: number;\r\n  count: number;\r\n  ratio: number;\r\n  // uniqueMovingAverage: number\r\n  // movingAverage: number\r\n  // uniqueDistance: number\r\n  // countDistance: number\r\n}\r\n\r\nconst queries = {\r\n  createWords: [\r\n    `CREATE TABLE IF NOT EXISTS words (\r\n     id INTEGER PRIMARY KEY,\r\n     word TEXT UNIQUE\r\n  );`,\r\n  ],\r\n  createWordHistory: [\r\n    `CREATE TABLE IF NOT EXISTS word_history (\r\n       id INTEGER PRIMARY KEY,\r\n       account_id INTEGER NOT NULL,\r\n       word_id INTEGER NOT NULL,\r\n       timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n       FOREIGN KEY (word_id) REFERENCES words(id)\r\n    );`,\r\n    `CREATE INDEX IF NOT EXISTS account_idx ON word_history (account_id);`,\r\n    `CREATE INDEX IF NOT EXISTS word_idx ON word_history (word_id);`,\r\n  ],\r\n  createAccounts: [\r\n    `CREATE TABLE IF NOT EXISTS users (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      username TEXT NOT NULL\r\n    );`,\r\n    `CREATE INDEX IF NOT EXISTS idx_username ON users (username COLLATE NOCASE);`,\r\n  ],\r\n  insertNewWords: `INSERT OR IGNORE INTO words (word) VALUES $$;`,\r\n  insertNewWordHistory: `INSERT INTO word_history (account_id, word_id, timestamp) VALUES (:account_id, :word_id, DATETIME(:timestamp));`,\r\n  insertUser: `INSERT INTO users (username) VALUES (:username);`,\r\n  getNewWords: `SELECT id, word FROM words WHERE word IN $$;`,\r\n  getUser: `SELECT id, username FROM users WHERE username = :username LIMIT 1;`,\r\n  getUniqueWords: `SELECT \r\n      CAST(strftime('%s', strftime('%Y-%m-%d %H:00:00', timestamp)) AS INT) * 1000 AS hour, \r\n      COUNT(DISTINCT word_id) AS uniqueCount,\r\n      COUNT(word_id) AS count,\r\n      COUNT(DISTINCT word_id) / COUNT(word_id) AS ratio\r\n    FROM word_history\r\n    WHERE account_id = :account_id\r\n    GROUP BY hour\r\n    ORDER BY hour ASC;`,\r\n  getWordHistory: `SELECT \r\n      CAST(strftime('%s', strftime('%Y-%m-%d %H:00:00', timestamp)) AS INT) * 1000 AS hour, \r\n      word_id\r\n    FROM word_history\r\n    WHERE account_id = :account_id\r\n    ORDER BY hour ASC;`,\r\n  getWords: `SELECT id, word FROM words;`,\r\n};\r\n\r\nexport default class WordCache {\r\n  path: string;\r\n  connection: ReturnType<typeof getDb>;\r\n  cache: {\r\n    [key: string]: number;\r\n  } = {};\r\n\r\n  /**\r\n   *\r\n   */\r\n  constructor(path: string = __dirname + '/../dist/wordCache.db') {\r\n    this.path = path;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param path\r\n   */\r\n  async connect(path: string = this.path) {\r\n    this.connection = getDb(path);\r\n    queries.createWords.forEach((query) => this.connection.exec(query));\r\n    queries.createWordHistory.forEach((query) => this.connection.exec(query));\r\n    queries.createAccounts.forEach((query) => this.connection.exec(query));\r\n    await this.populate();\r\n    return this;\r\n  }\r\n  /**\r\n   *\r\n   */\r\n  async getUserId(username: string | number) {\r\n    if (typeof username === 'number') {\r\n      return username;\r\n    }\r\n\r\n    const user = await query<User>(this.connection, queries.getUser, {\r\n      username,\r\n    });\r\n\r\n    if (user.length > 0) {\r\n      return user[0].id;\r\n    } else {\r\n      const result = run(this.connection, queries.insertUser, {\r\n        username,\r\n      }) as unknown as insertResult;\r\n\r\n      return result.lastInsertRowid;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns\r\n   */\r\n  async getReport(account_id: number) {\r\n    const timeline = await query<UniqueWords>(\r\n      this.connection,\r\n      queries.getUniqueWords,\r\n      {\r\n        account_id,\r\n      }\r\n    );\r\n\r\n    if (timeline.length === 0) {\r\n      return timeline;\r\n    }\r\n\r\n    const wordHistory = await query<UsageEntry>(\r\n      this.connection,\r\n      queries.getWordHistory,\r\n      {\r\n        account_id,\r\n      }\r\n    );\r\n\r\n    let time = timeline[0].hour;\r\n    const max = timeline[timeline.length - 1].hour + 1;\r\n    const times: number[] = [];\r\n    const uniqueCounts: number[] = [];\r\n    const counts: number[] = [];\r\n\r\n    for (; time < max; time += msInHour) {\r\n      times.push(time);\r\n      const event = timeline.find((event) => event.hour === time);\r\n\r\n      if (event === undefined) {\r\n        uniqueCounts.push(0);\r\n        counts.push(0);\r\n      } else {\r\n        uniqueCounts.push(event.uniqueCount);\r\n        counts.push(event.count);\r\n      }\r\n    }\r\n\r\n    const knownWords: number[] = [];\r\n    const result: UniqueWords[] = times.map((time, i) => {\r\n      let newGrammar = 0;\r\n      wordHistory\r\n        .filter((word) => word.hour === time)\r\n        .forEach((word) => {\r\n          if (knownWords.indexOf(word.word_id) === -1) {\r\n            newGrammar += 1;\r\n            knownWords.push(word.word_id);\r\n          }\r\n        });\r\n\r\n      return {\r\n        hour: time,\r\n        count: counts[i],\r\n        uniqueCount: uniqueCounts[i],\r\n        ratio: counts[i] === 0 ? 0 : uniqueCounts[i] / counts[i],\r\n        newGrammar,\r\n      };\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  reset() {\r\n    if (this.connection) {\r\n      this.connection.close();\r\n    }\r\n\r\n    reset(this.path);\r\n    rmSync(this.path);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  async addUsages(\r\n    wordEntries: WordCacheEntries,\r\n    username: string | number,\r\n    timestamp: string | Date\r\n  ) {\r\n    const user_id = await this.getUserId(username);\r\n    const timeValue =\r\n      timestamp instanceof Date\r\n        ? timestamp.toISOString().slice(0, -5)\r\n        : timestamp;\r\n\r\n    for (const word of Object.keys(wordEntries)) {\r\n      const entry = wordEntries[word];\r\n      for (let i = 0; i < entry.amount; i++) {\r\n        this.addUsage(entry.id, user_id, timeValue);\r\n      }\r\n    }\r\n\r\n    return user_id;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  async addUsage(\r\n    word_id: number,\r\n    account_id: number,\r\n    timestamp: string | Date\r\n  ) {\r\n    await run(this.connection, queries.insertNewWordHistory, {\r\n      word_id,\r\n      account_id,\r\n      timestamp,\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  async fetch(sentence: string) {\r\n    const tokens = this.tokenize(sentence);\r\n    const newWords = [];\r\n    const results: {\r\n      [key: string]: WordCacheEntry;\r\n    } = {};\r\n\r\n    for (const token of tokens) {\r\n      if (this.cache[token] === undefined) {\r\n        // Word is not cached\r\n        newWords.push(token);\r\n      } else {\r\n        // Use cache\r\n        if (results[token] === undefined) {\r\n          // Result doesn't exist\r\n          results[token] = {\r\n            id: this.cache[token],\r\n            amount: 0,\r\n          };\r\n        }\r\n\r\n        results[token].amount += 1;\r\n      }\r\n    }\r\n\r\n    // Go get new words\r\n    const newRecords = await this.getsert(newWords);\r\n\r\n    for (const record of newRecords) {\r\n      this.cache[record.word] = record.id;\r\n\r\n      if (results[record.word] === undefined) {\r\n        results[record.word] = {\r\n          id: this.cache[record.word],\r\n          amount: 0,\r\n        };\r\n      }\r\n\r\n      results[record.word].amount += 1;\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  private tokenize(sentence: string): string[] {\r\n    const doc = nlp.readDoc(\r\n      sentence.toLowerCase().replace(singleQuotes, '').replace(newLines, ' ')\r\n    );\r\n    return doc.tokens().out();\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  private async populate() {\r\n    const rows = await query<Word>(this.connection, queries.getWords);\r\n    console.log(rows);\r\n    for (const row of rows) {\r\n      this.cache[row.word] = row.id;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  private async getsert(sentence: string | string[]) {\r\n    const tokens =\r\n      sentence instanceof Array ? sentence : this.tokenize(sentence);\r\n\r\n    if (tokens.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const words = `('${tokens.join(`'), ('`)}')`;\r\n    await run(this.connection, queries.insertNewWords.replace('$$', words));\r\n\r\n    const wordList = `('${tokens.join(`', '`)}')`;\r\n    const rows = query<Word>(\r\n      this.connection,\r\n      queries.getNewWords.replace('$$', wordList),\r\n      {}\r\n    );\r\n\r\n    return rows;\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}