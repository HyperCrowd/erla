{"version":3,"sources":["../../src/csv.ts","../../src/sqlite.ts","../../src/wordCache.ts"],"sourcesContent":["import * as csv from 'csv-stream';\r\nimport { open } from 'node:fs/promises';\r\nimport * as pe from 'post-entity';\r\nimport WordCache from '../src/wordCache';\r\n\r\nconst file = process.argv[2] || '';\r\n\r\nif (file === '') {\r\n  throw new RangeError();\r\n}\r\n\r\nconst tokens = {};\r\n// Initialize the parser\r\nconst options = {\r\n  delimiter: '\\t',\r\n  endLine: '\\n',\r\n  columnOffset: 0,\r\n  escapeChar: '\"',\r\n  enclosedChar: '\"',\r\n};\r\n\r\nconst csvStream = csv.createStream(options);\r\n\r\nlet prompt = `Using a list of words where the number after the comma is how frequently the word is used, give a detailed and critical summary (without using any positive terminology) about the personality, interests, fears, and hopes of the person using these words from the list (and account for frequency): \r\n\r\n`;\r\n\r\nconst alphanumOnly = /[^a-z\\-]/g;\r\n\r\n/**\r\n *\r\n */\r\nasync function main() {\r\n  const cache = new WordCache(`${process.cwd()}/tests/test.db`, false)\r\n    .reset()\r\n    .connect();\r\n  let user_id;\r\n  const fd = await open(file, 'r');\r\n  const stream = fd.createReadStream();\r\n  stream\r\n    .pipe(csvStream)\r\n\r\n    .on('data', function (data) {\r\n      // outputs an object containing a set of key/value pair representing a line found in the csv file.\r\n      if (data.retweet !== 'False') {\r\n        return;\r\n      }\r\n\r\n      if (data.language !== 'en') {\r\n        return;\r\n      }\r\n      const tweet = data.tweet.toLowerCase();\r\n\r\n      const text = pe\r\n        .process(tweet)\r\n        .filter((tweet) => tweet.type === 'text')\r\n        .map((tweet) => tweet.raw.trim());\r\n\r\n      for (const words of text) {\r\n        const usages = cache.fetch(words);\r\n        user_id = cache.addUsages(\r\n          usages,\r\n          data.username,\r\n          new Date(data.created_at)\r\n        );\r\n      }\r\n    })\r\n\r\n    .on('close', function () {\r\n      const report = cache.getReport(user_id);\r\n      console.log(JSON.stringify(report));\r\n    });\r\n}\r\n\r\nmain();\r\n","import SqliteDatabaseConnection from 'better-sqlite3';\r\nimport { ensureFileSync } from 'fs-extra';\r\n\r\n/**\r\n * A cache of all connections\r\n */\r\nconst cache: {\r\n  [key: string]: SqliteDatabaseConnection;\r\n} = {};\r\n\r\n/**\r\n * Get a sqlite database connection\r\n */\r\nexport const getDb = (path: string) => {\r\n  if (cache[path] === undefined) {\r\n    ensureFileSync(path);\r\n    cache[path] = new SqliteDatabaseConnection(path);\r\n    cache[path].exec('PRAGMA journal_mode = OFF;');\r\n    cache[path].exec('PRAGMA synchronous = 0;');\r\n    cache[path].exec('PRAGMA cache_size = 1000000;');\r\n    cache[path].exec('PRAGMA locking_mode = EXCLUSIVE');\r\n    cache[path].exec('PRAGMA temp_store = MEMORY;');\r\n  }\r\n\r\n  return cache[path];\r\n};\r\n\r\n/**\r\n *\r\n * @param path\r\n */\r\nexport const reset = (path: string) => {\r\n  cache[path] = undefined;\r\n};\r\n\r\n/**\r\n * run\r\n */\r\nexport const run = <T = Object>(\r\n  db: SqliteDatabaseConnection,\r\n  query: string,\r\n  parameters: Object | undefined = undefined\r\n): T[] => {\r\n  const statement = db.prepare(query);\r\n  if (parameters === undefined) {\r\n    return statement.run();\r\n  } else {\r\n    return statement.bind(parameters).run();\r\n  }\r\n};\r\n\r\n/**\r\n * query\r\n * @param query sql\r\n * @param parameters Object\r\n * @param db SqliteDatabaseConnection\r\n * @return Object[]\r\n */\r\nexport const query = <T = Object>(\r\n  db: SqliteDatabaseConnection,\r\n  query: string,\r\n  parameters: Object = {}\r\n): T[] => {\r\n  const statement = db.prepare(query);\r\n  return statement.bind(parameters).all();\r\n};\r\n","import { getDb, run, query, reset } from './sqlite';\r\nimport winkNLP from 'wink-nlp';\r\nimport model from 'wink-eng-lite-web-model';\r\nimport { rmSync } from 'fs-extra';\r\n\r\nconst singleQuotes = /'/g;\r\nconst newLines = /[\\n\\r]/g;\r\nconst msInHour = 1000 * 60 * 60;\r\n\r\n// Instantiate winkNLP.\r\nconst nlp = winkNLP(model);\r\n\r\ninterface Word {\r\n  id: number;\r\n  word: string;\r\n}\r\n\r\ninterface insertResult {\r\n  lastInsertRowid: number;\r\n}\r\n\r\ninterface WordCacheEntries {\r\n  [key: string]: WordCacheEntry;\r\n}\r\n\r\ninterface WordCacheEntry {\r\n  id: number;\r\n  amount: number;\r\n}\r\n\r\ninterface UsageEntry {\r\n  hour: number;\r\n  word_id: number;\r\n  timestamp: number;\r\n}\r\n\r\ninterface User {\r\n  id: number;\r\n  username: string;\r\n}\r\n\r\ninterface UniqueWords {\r\n  hour: number;\r\n  uniqueCount: number;\r\n  count: number;\r\n  ratio: number;\r\n  // uniqueMovingAverage: number\r\n  // movingAverage: number\r\n  // uniqueDistance: number\r\n  // countDistance: number\r\n}\r\n\r\nconst queries = {\r\n  createWords: [\r\n    `CREATE TABLE IF NOT EXISTS words (\r\n     id INTEGER PRIMARY KEY,\r\n     word TEXT UNIQUE\r\n  );`,\r\n  ],\r\n  createWordHistory: [\r\n    `CREATE TABLE IF NOT EXISTS word_history (\r\n       id INTEGER PRIMARY KEY,\r\n       account_id INTEGER NOT NULL,\r\n       word_id INTEGER NOT NULL,\r\n       timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n       FOREIGN KEY (word_id) REFERENCES words(id)\r\n    );`,\r\n    `CREATE INDEX IF NOT EXISTS account_idx ON word_history (account_id);`,\r\n    `CREATE INDEX IF NOT EXISTS word_idx ON word_history (word_id);`,\r\n  ],\r\n  createAccounts: [\r\n    `CREATE TABLE IF NOT EXISTS users (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      username TEXT NOT NULL\r\n    );`,\r\n    `CREATE INDEX IF NOT EXISTS idx_username ON users (username COLLATE NOCASE);`,\r\n  ],\r\n  insertNewWords: `INSERT OR IGNORE INTO words (word) VALUES $$;`,\r\n  insertNewWordHistory: `INSERT INTO word_history (account_id, word_id, timestamp) VALUES (:account_id, :word_id, DATETIME(:timestamp));`,\r\n  insertUser: `INSERT INTO users (username) VALUES (:username);`,\r\n  getNewWords: `SELECT id, word FROM words WHERE word IN $$;`,\r\n  getUser: `SELECT id, username FROM users WHERE username = :username LIMIT 1;`,\r\n  getUniqueWords: `SELECT \r\n      CAST(strftime('%s', strftime('%Y-%m-%d %H:00:00', timestamp)) AS INT) * 1000 AS hour, \r\n      COUNT(DISTINCT word_id) AS uniqueCount,\r\n      COUNT(word_id) AS count,\r\n      COUNT(DISTINCT word_id) / COUNT(word_id) AS ratio\r\n    FROM word_history\r\n    WHERE account_id = :account_id\r\n    GROUP BY hour\r\n    ORDER BY hour ASC;`,\r\n  getWordHistory: `SELECT \r\n      CAST(strftime('%s', strftime('%Y-%m-%d %H:00:00', timestamp)) AS INT) * 1000 AS hour, \r\n      word_id\r\n    FROM word_history\r\n    WHERE account_id = :account_id\r\n    ORDER BY hour ASC;`,\r\n  getWords: `SELECT id, word FROM words;`,\r\n};\r\n\r\nexport default class WordCache {\r\n  path: string;\r\n  connection: ReturnType<typeof getDb>;\r\n  cache: {\r\n    [key: string]: number;\r\n  } = {};\r\n\r\n  /**\r\n   *\r\n   */\r\n  constructor(\r\n    path: string = __dirname + '/../../../assets/wordCache.db',\r\n    autoConnect = true\r\n  ) {\r\n    this.path = path;\r\n    if (autoConnect) {\r\n      this.connect(path);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param path\r\n   */\r\n  connect(path: string = this.path) {\r\n    this.connection = getDb(path);\r\n    queries.createWords.forEach((query) => this.connection.exec(query));\r\n    queries.createWordHistory.forEach((query) => this.connection.exec(query));\r\n    queries.createAccounts.forEach((query) => this.connection.exec(query));\r\n    this.populate();\r\n    return this;\r\n  }\r\n  /**\r\n   *\r\n   */\r\n  getUserId(username: string | number) {\r\n    if (typeof username === 'number') {\r\n      return username;\r\n    }\r\n\r\n    const user = query<User>(this.connection, queries.getUser, {\r\n      username,\r\n    });\r\n\r\n    if (user.length > 0) {\r\n      return user[0].id;\r\n    } else {\r\n      const result = run(this.connection, queries.insertUser, {\r\n        username,\r\n      }) as unknown as insertResult;\r\n\r\n      return result.lastInsertRowid;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns\r\n   */\r\n  getReport(account_id: number) {\r\n    const timeline = query<UniqueWords>(\r\n      this.connection,\r\n      queries.getUniqueWords,\r\n      {\r\n        account_id,\r\n      }\r\n    );\r\n\r\n    if (timeline.length === 0) {\r\n      return timeline;\r\n    }\r\n\r\n    const wordHistory = query<UsageEntry>(\r\n      this.connection,\r\n      queries.getWordHistory,\r\n      {\r\n        account_id,\r\n      }\r\n    );\r\n\r\n    let time = timeline[0].hour;\r\n    const max = timeline[timeline.length - 1].hour + 1;\r\n    const times: number[] = [];\r\n    const uniqueCounts: number[] = [];\r\n    const counts: number[] = [];\r\n\r\n    for (; time < max; time += msInHour) {\r\n      times.push(time);\r\n      const event = timeline.find((event) => event.hour === time);\r\n\r\n      if (event === undefined) {\r\n        uniqueCounts.push(0);\r\n        counts.push(0);\r\n      } else {\r\n        uniqueCounts.push(event.uniqueCount);\r\n        counts.push(event.count);\r\n      }\r\n    }\r\n\r\n    const knownWords: number[] = [];\r\n    const result: UniqueWords[] = times.map((time, i) => {\r\n      let newGrammar = 0;\r\n      wordHistory\r\n        .filter((word) => word.hour === time)\r\n        .forEach((word) => {\r\n          if (knownWords.indexOf(word.word_id) === -1) {\r\n            newGrammar += 1;\r\n            knownWords.push(word.word_id);\r\n          }\r\n        });\r\n\r\n      return {\r\n        hour: time,\r\n        count: counts[i],\r\n        uniqueCount: uniqueCounts[i],\r\n        ratio: counts[i] === 0 ? 0 : uniqueCounts[i] / counts[i],\r\n        newGrammar,\r\n      };\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  reset() {\r\n    if (this.connection) {\r\n      this.connection.close();\r\n    }\r\n\r\n    reset(this.path);\r\n    rmSync(this.path);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  addUsages(\r\n    wordEntries: WordCacheEntries,\r\n    username: string | number,\r\n    timestamp: string | Date\r\n  ) {\r\n    const user_id = this.getUserId(username);\r\n    const timeValue =\r\n      timestamp instanceof Date\r\n        ? timestamp.toISOString().slice(0, -5)\r\n        : timestamp;\r\n\r\n    for (const word of Object.keys(wordEntries)) {\r\n      const entry = wordEntries[word];\r\n      for (let i = 0; i < entry.amount; i++) {\r\n        this.addUsage(entry.id, user_id, timeValue);\r\n      }\r\n    }\r\n\r\n    return user_id;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  addUsage(word_id: number, account_id: number, timestamp: string | Date) {\r\n    run(this.connection, queries.insertNewWordHistory, {\r\n      word_id,\r\n      account_id,\r\n      timestamp,\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  fetch(sentence: string) {\r\n    const tokens = this.tokenize(sentence);\r\n    const newWords = [];\r\n    const results: {\r\n      [key: string]: WordCacheEntry;\r\n    } = {};\r\n\r\n    for (const token of tokens) {\r\n      if (this.cache[token] === undefined) {\r\n        // Word is not cached\r\n        newWords.push(token);\r\n      } else {\r\n        // Use cache\r\n        if (results[token] === undefined) {\r\n          // Result doesn't exist\r\n          results[token] = {\r\n            id: this.cache[token],\r\n            amount: 0,\r\n          };\r\n        }\r\n\r\n        results[token].amount += 1;\r\n      }\r\n    }\r\n\r\n    // Go get new words\r\n    const newRecords = this.getsert(newWords);\r\n\r\n    for (const record of newRecords) {\r\n      this.cache[record.word] = record.id;\r\n\r\n      if (results[record.word] === undefined) {\r\n        results[record.word] = {\r\n          id: this.cache[record.word],\r\n          amount: 0,\r\n        };\r\n      }\r\n\r\n      results[record.word].amount += 1;\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  private tokenize(sentence: string): string[] {\r\n    const doc = nlp.readDoc(\r\n      sentence.toLowerCase().replace(singleQuotes, '').replace(newLines, ' ')\r\n    );\r\n    return doc.tokens().out();\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  private populate() {\r\n    const rows = query<Word>(this.connection, queries.getWords);\r\n\r\n    for (const row of rows) {\r\n      this.cache[row.word] = row.id;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  private getsert(sentence: string | string[]) {\r\n    const tokens =\r\n      sentence instanceof Array ? sentence : this.tokenize(sentence);\r\n\r\n    if (tokens.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const words = `('${tokens.join(`'), ('`)}')`.replace(`$`, `S`);\r\n    run(this.connection, queries.insertNewWords.replace('$$', words));\r\n\r\n    const wordList = `('${tokens.join(`', '`)}')`.replace(`$`, `S`);\r\n    const rows = query<Word>(\r\n      this.connection,\r\n      queries.getNewWords.replace('$$', wordList),\r\n      {}\r\n    );\r\n\r\n    return rows;\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}